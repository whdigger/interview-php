### 1. Какие типы таблиц вы знаете

ISAM, HEAP, MyISAM, InnoDB

### 2. В чем отличие MyISAM и InnoDB?

MyISAM:

- не поддерживает транзакции и с этим связаны его основные недостатки и преимущества;
- в большинстве случаев он быстрее, так как нет расходов на транзакции;
- занимает меньше дискового пространства;
- меньше расход памяти на обновления;
- полнотекстовый индекс;
- быстрый INSERT, SELECT.

InnoDB:

- поддержка транзакций;
- построчная блокировка.
- UPDATE не блокирует всю таблицу;
- отлично ведет себя при смешанной нагрузке (insert|select|update|delete).

### 3. Что такое первичный ключ

Первичный ключ является полем в таблице, которое однозначно идентифицирует каждую строку/запись в таблице базы данных.
Первичные ключи должны содержать уникальные значения. Первичный ключ столбец не может иметь значения NULL.

### 4. Что такое внешний ключ

Внешние ключи позволяют установить связи между таблицами.
Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы.
Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

### 5. Для чего создаются индексы в базе данных, как работают индексы, какие бывают, что такое составные индексы, какие использовал, чем отличаются, как влияют на производительность

Индексы отсортированный набор значений, создаются с целью повышения производительности поиска данных.
Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и,
таким образом, позволяет искать строки, удовлетворяющие критерию поиска.
Составной индекс – это индекс, построенный по нескольким колонкам. Такие индексы имеет смысл использовать, когда в одном
запросе фигурируют более одной колонки.

### 6. Какие индексы куда лучше ставить, на всё ли нужно ставить индексы, на что нужно на что нет.

Выбор оптимальных индексов зависит от структуры и запросов к конкретной таблице базы данных.

**_Виды индексов_**: для поиска, сортировки, уникальные, для полнотекстового поиска.

_**Общие правила построение индексов**_:

- Индексировать столбцы, используемые в предикатах WHERE, JOIN и ORDER BY
- Избегать излишнего индексирования: Не стоит индексировать каждый столбец в таблице, особенно если они не используются
  в запросах или имеют низкую селективность (т.е. мало уникальных значений). Индексы требуют дополнительного
  пространства и влияют на производительность операций вставки, обновления и удаления данных, поэтому лучше выбирать
  индексы осознанно и оптимизировать их использование.

- Учитывайте размер и объем данных: Если таблица очень маленькая или содержит небольшое количество записей, может не
  быть необходимости в индексах.

- Анализируйте производительность запросов: Используйте профилирование запросов и инструменты анализа производительности
  для идентификации узких мест и определения, где необходимо добавить индексы. Проверяйте планы выполнения запросов и
  ищите места, где полные сканирования таблиц можно заменить использованием индексов.

- Учитывайте изменяемость данных: Если данные в таблице часто изменяются (вставка, обновление, удаление), то индексы
  также должны обновляться, что может замедлить операции записи. В таких случаях необходимо тщательно балансировать
  потребности в индексировании и производительности операций изменения данных.

При использовании составных индексов порядок полей в индексе имеет определяющее значение.

### 7. Что такое селективность индексов

Один из основных параметров, характеризующий индекс — селективность(selectivity) - определяется количеством записей в
таблице с одинаковыми значениями.
Когда записей c уникальными значениями много(с одинаковым значением мало) – селективность высокая. Такие колонки
необходимо использовать первыми в составных индексах.

### 8. Какая разница между LEFT, RIGHT и INNER JOIN?

- INNER JOIN: возвращает строки, когда есть совпадение в обеих таблицах.
- LEFT JOIN: возвращает все строки из левой таблицы, даже если в правой таблице нет совпадений.
- RIGHT JOIN: возвращает все строки из правой таблицы, даже если в левой таблице нет совпадений.

### 9. Чем отличается HAVING от WHERE

**WHERE** - используется для фильтрации строк перед выполнением группировки

**HAVING** - используется для фильтрации результатов после выполнения группировки и агрегатных функций

Основное отличие между HAVING и WHERE заключается в том, что WHERE применяется к отдельным строкам данных до
группировки, а HAVING применяется к группам данных после группировки.

### 10. Какие уровни транзакции знаешь?

**READ UNCOMMITTED (неподтвержденное чтение)**: Это самый низкий уровень изоляции, при котором транзакции могут видеть
изменения внесенные другими транзакциями, которые еще не были подтверждены. Этот уровень предоставляет самую низкую
степень изоляции данных, но может привести к проблемам "грязного чтения" и "неповторяющегося чтения".

**READ COMMITTED (подтвержденное чтение)**: Это уровень, при котором транзакции видят только изменения, подтвержденные
другими транзакциями. Это предотвращает проблему "грязного чтения", но может все еще приводить к проблеме"
неповторяющегося чтения".

**REPEATABLE READ (повторяемое чтение)**: Это уровень, при котором транзакции видят согласованное состояние данных в
пределах одной транзакции - это означает, что другие транзакции не могут изменять данные, которые были прочитаны текущей транзакцией.
Если транзакция выполняет несколько запросов к одним и тем же данным, то она всегда будет видеть одни и те же значения этих данных.
Это предотвращает проблемы "грязного чтения" и "неповторяющегося чтения", но может все еще возникать проблема "фантомного чтения".

**SERIALIZABLE (сериализуемость)**: Это самый высокий уровень изоляции, при котором транзакции видят данные, как если бы
они выполнялись последовательно одна за другой. Это предотвращает все проблемы изоляции данных, но может приводить к потере
параллельности и снижению производительности при работе с большим количеством одновременных транзакций.

### 11. Что такое команда EXPLAIN и для чего вы её использовали

**EXPLAIN** может в точности рассказать, что происходит, когда вы выполняете запрос.
Эта информация позволит обнаружить медленные запросы и сократить время, затрачиваемое на обработку запроса, что
впоследствии может значительно ускорить работу вашего приложения

### 12. Что делает команда GROUP BY

Команда GROUP BY группирует результаты при выборке из базы данных.

### 13. Как работает синтаксический анализатор sql, какой приоритет операторов и операций

- **Лексический анализ (Lexical analysis)**: Синтаксический анализатор считывает входной текст SQL запроса и разбивает
  его на лексемы (токены). Лексемы могут быть ключевыми словами (SELECT, FROM, WHERE), идентификаторами (названия
  таблиц, столбцов), операторами, значениями и другими элементами языка SQL.
- **Синтаксический анализ (Syntax analysis)**: Анализатор проверяет синтаксическую корректность запроса, основываясь на
  грамматике SQL. Он строит синтаксическое дерево (парсерное дерево), которое представляет структуру запроса и его
  взаимосвязи между элементами. При этом проверяются правильность расстановки ключевых слов, операторов, скобок и других
  синтаксических правил.
- **Семантический анализ (Semantic analysis)**: Анализатор проводит семантическую проверку запроса, основываясь на
  семантике SQL. Он проверяет правильность ссылок на таблицы и столбцы, типы данных, права доступа и другие
  семантические правила. Если обнаружены ошибки, генерируется сообщение об ошибке.
- **Построение внутреннего представления (Internal representation)**: После успешного анализа, синтаксический анализатор
  строит внутреннее представление запроса, которое может быть использовано другими компонентами СУБД для выполнения
  запроса. Это может быть абстрактное синтаксическое дерево, план выполнения запроса или другая форма представления.
- **Оптимизация запроса (Query optimization)**: Некоторые СУБД имеют шаг оптимизации запроса, который анализирует
  внутреннее представление и пытается найти оптимальный способ выполнения запроса, используя различные алгоритмы и
  эвристики. Это может включать выбор индексов, определение порядка выполнения операций и другие оптимизации.

**Приоритеты операторов по убыванию**:

- круглые скобки
- умножение (*), деление (/)
- сложение (+), вычитание (-)
- операторы сравнения (=, >, <, >=, <=, <>)
- NOT
- AND
- OR

**Приоритеты операций по убыванию**:

- FROM (выбор таблицы)
- JOIN (комбинация с подходящими по условию данными из других таблиц)
- WHERE (фильтрация строк)
- GROUP BY (агрегирование данных)
- HAVING (фильтрация агрегированных данных)
- SELECT (возврат результирующего датасета)
- ORDER BY (сортировка).

### 14. Что такое btree, hash map индексы?

**B-дерево (B-tree)**:

B-дерево является сбалансированным деревом поиска, где каждый узел может содержать несколько ключей и ссылок на дочерние узлы.
Использует принцип бинарного поиска и используется для индексации данных. Индексы обычно используются для поиска
диапазонов значений, сортировки данных и поддержки операций JOIN.

**Хеш-индексы (hash map indexes)**:

Хеш-индекс использует хеш-функции для преобразования ключей данных в адреса в хеш-таблице.
Хеш-таблица представляет собой структуру данных, где каждому ключу соответствует значение.
Хеш-индексы обычно используются для точного поиска по ключу, а не для поиска диапазонов значений или сортировки данных.
Однако, в отличие от B-дерева, хеш-индексы не поддерживают операции сортировки и JOIN.

### 15. Почему в hash map индексах нельзя использовать LIKE

Оператор LIKE в SQL обычно используется для поиска шаблонов в строковых значениях. Он позволяет искать значения,
соответствующие заданному шаблону, который может содержать символы-маски. Оператор LIKE не является прямым
сопоставлением ключа, а требует выполнения поиска с использованием регулярных выражений или подобных механизмов.

### 16. Как вывести только уникальные результаты, то есть убрать дубли

SELECT DISTINCT

### 17. Как сделать constraint на поле с default значение в БД

ALTER TABLE table_name
MODIFY COLUMN column_name data_type DEFAULT default_value constraint_name;

### 18. У нас есть одно поле id на нем есть индекс, одна запись, как выбрать поле чтобы индекс не отработал?

Использовать преобразование к типу varchar или использовать string в запросе.

### 19. У нас есть миллион записей если выбрать например where id > 2, то индекс не отработает.

В данном случае, когда условие WHERE сравнивает поле с большим количеством записей, использование индекса может быть
неэффективным.

- Проверьте селективность условия: Убедитесь, что условие WHERE на самом деле ограничивает количество возвращаемых
  строк. Если условие выбирает большую часть или все записи, то использование индекса может не принести значительной
  выгоды.
- Оптимизируйте запрос: Проверьте план выполнения запроса и убедитесь, что он оптимальный.
- Разбейте запрос на части: Если условие WHERE неэффективно из-за большого количества данных, можно попробовать разбить
  запрос на несколько более мелких запросов с более узкими условиями, а затем объединить результаты.
- Используйте другие индексы: Проверьте, имеются ли другие поля, которые могут быть использованы для создания индекса,
  чтобы улучшить производительность запроса. Иногда изменение индекса или добавление дополнительных индексов может быть
  полезным.

### 20. Есть большая таблица нужно вывести постранично записи по 100 как сделать и почему?

Необходимо использовать выражение field_name > id
Использование LIMIT OFFSET не стоит использовать на большие выборки из-за того что происходит сдвиг и индексы перестают
работать.

### 21. Как осуществить разбиение по серверам большую таблицу? Какой алгоритм применить?

В простом случае простым деление на количество серверов и брать остаток от деления. В более сложном, использовать
консистентное хеширование

### 22. Есть таблица с 90 миллионов записей из неё нужно удалять данные которые старше 60 дней, какие подводные камни могут быть.

Будет происходить блокировка таблицы на время удаления необходимо ограничить запрос LIMIT 1

### 23. Как можно улучшить ваш запрос?

Есть огромная таблица заказов и таблица с одной ячейкой, в которой указана дата. Нужно посчитать сумму оплат по заказам,
которые были позже даты, указанной во второй таблице.
SELECT SUM(price) FROM orders WHERE orders.date > (SELECT date FROM time)

SELECT SUM(price) FROM orders JOIN time ON orders.date > time.date
Добавить индекс на date в таблице orders и time по убыванию.
Пакетная обработка данных, кэширование результатов, оптимизация аппаратного обеспечения

### 24. Расскажите об операторе JOIN, приведите примеры и варианты использования. Когда JOIN использовать не стоит?

Оператор JOIN служит для объединения нескольких таблиц и включения этих данных в выходной набор.

- Небольшой объем данных и простые запросы
- Индексы отсутствуют или неоптимальны: Если таблицы, которые вы хотите объединить, не имеют соответствующих индексов
  или индексы не оптимизированы для выполнения операции JOIN, это может привести к плохой производительности.
- Сложные или многоступенчатые JOIN операции: Если вам требуется выполнить сложные или многоступенчатые операции JOIN с
  большим количеством таблиц, это может привести к сложному плану выполнения запроса и снижению производительности.
- Использование полных соединений (FULL JOIN): Полные соединения объединяют данные из всех таблиц, включая строки,
  которые не имеют совпадений. Это может привести к большому объему данных и медленной производительности.

### 25. Как снять нагрузку?

<details>
    <summary>Репликация</summary>
Создание полного дубликата базы данных. Так, вместо одного сервера их будет несколько, обычно используется схема master-slave
</details>

<details>
    <summary>Шардинг</summary>
Техника масштабирования работы с данными. Суть его в разделении (партиционирование) базы данных на отдельные части так,
чтобы каждую из них можно было вынести на отдельный сервер. Этот процесс зависит от структуры базы данных и выполняется
прямо в приложении в отличие от репликации существуют два вида шардирования:

- **Вертикальный шардинг** — это выделение таблицы или группы таблиц на отдельный сервер.
- **Горизонтальный шардинг** — это разделение одной таблицы на разные сервера. Это необходимо использовать для огромных
  таблиц, которые не умещаются на одном сервере.

</details>

### 26. Какие индексы вы использовали для оптимизации запросов? Как выбирать подходящие индексы?

Когда речь идет о выборе подходящих индексов для оптимизации запросов, есть несколько факторов, которые стоит учитывать:

<details>
    <summary>Анализ запросов</summary>
Изучите типы запросов, которые выполняются на вашей таблице. Определите, какие столбцы часто используются в условиях WHERE, JOIN или ORDER BY. Это поможет вам определить, на какие столбцы следует создать индексы.
</details>

<details>
    <summary>Селективность столбцов</summary>
Оцените уникальность значений в столбцах, на которые вы планируете создать индексы. Если столбец имеет высокую Селективность (много уникальных значений), то индексирование этого столбца может быть более эффективным.
</details>

<details>
    <summary>Размер данных</summary>
Учтите размер данных в столбцах, которые вы планируете индексировать.
</details>

<details>
    <summary>Обновление данных</summary>
Рассмотрите частоту обновления данных в таблице. Индексы улучшают производительность чтения, но при обновлении или вставке данных индексы должны быть обновлены, что может замедлить процесс.
</details>

<details>
    <summary>Использование объединенных индексов</summary>
Иногда создание комбинированных индексов на несколько столбцов может быть полезным.
</details>

Избегайте создания слишком большого количества индексов, так как это может увеличить размер базы данных и замедлить операции записи.

### 27. Каким образом оптимизируете запросы с объединениями?

В основном используются те же правила создания индексов, что и для обычных запросов – индекс для колонок в WHERE.
В сложных выборках выбирайте индексы (перебором), которые позволят уменьшить число "rows" в EXPLAIN запроса.

В особо сложных случаях – денормализация и кеширование. (Следует создать таблицу, оптимизированную под запрос и
синхронно её обновлять)

### 28. Какие методы кэширования есть в SQL?

<details>
    <summary>Кэширование результатов запросов (Query Result Caching)</summary>
Этот метод заключается в кэшировании результатов выполнения запросов, чтобы избежать повторного выполнения запросов с теми же параметрами. Результаты запроса сохраняются в кэше и возвращаются при повторном запросе с теми же параметрами.
</details>

<details>
    <summary>Кэширование данных (Data Caching)</summary>
Этот метод включает кэширование конкретных данных, которые часто запрашиваются из базы данных. Например, можно кэшировать отдельные строки или целые таблицы, чтобы избежать выполнения запросов к базе данных при каждом запросе данных.
</details>

<details>
    <summary>Кэширование запросов (Query Caching)</summary>
Этот метод кэширует сами запросы, а не только их результаты. Если запрос уже был выполнен ранее, то результаты запроса извлекаются из кэша, вместо выполнения запроса повторно.
</details>

<details>
    <summary>Кэширование планов выполнения (Execution Plan Caching)</summary>
При выполнении запросов база данных генерирует план выполнения, определяющий оптимальный способ получения данных. Планы выполнения могут быть кэшированы для повторного использования, чтобы избежать повторного анализа и планирования запроса.
</details>

<details>
    <summary>Кэширование метаданных (Metadata Caching)</summary>
Этот метод кэширует метаданные, такие как структура таблиц, схемы базы данных и другие связанные схематические данные. Кэширование метаданных может помочь ускорить выполнение запросов, связанных с анализом структуры базы данных.
</details>

### 29. Как вы оптимизируете работу с транзакциями в SQL? Какие подходы используете для улучшения производительности?

<details>
    <summary>Минимизация длительности транзакций</summary>
Старайтесь ограничивать объем работы, выполняемой внутри транзакции, чтобы уменьшить время блокировки ресурсов и конкуренцию с другими транзакциями. Разбейте большие задачи на более мелкие транзакции, если это возможно.
</details>

<details>
    <summary>Правильное использование индексов</summary>
Убедитесь, что таблицы, используемые в транзакциях, имеют подходящие индексы. Индексы могут значительно ускорить выполнение запросов внутри транзакций и снизить блокировки.
</details>

<details>
    <summary>Использование оптимистической блокировки (Optimistic Locking)</summary>
Вместо блокировки ресурсов на протяжении всей транзакции, можно использовать оптимистическую блокировку, где проверяется, изменились ли данные с момента начала транзакции.
Если данные не были изменены, транзакция может продолжиться без блокировки.
</details>

<details>
    <summary>Использование транзакционных изоляционных уровней</summary>
Выбор правильного уровня изоляции транзакций может повлиять на производительность и конкурентность.
Оцените требования вашего приложения и выберите подходящий уровень изоляции для достижения нужной согласованности данных и производительности.
</details>

<details>
    <summary>Пакетная обработка (Batch Processing)</summary>
Если вам не требуется немедленное применение изменений в базе данных, рассмотрите возможность пакетной обработки транзакций, где несколько операций объединяются и выполняются одновременно.
Это может сократить накладные расходы на установку и снятие блокировок.
</details>

<details>
    <summary>Использование хранимых процедур и представлений</summary>
Хранимые процедуры и представления могут уменьшить накладные расходы на сетевое взаимодействие и улучшить производительность, особенно при выполнении повторяющихся операций или сложных запросов.
</details>

<details>
    <summary>Оптимизация и профилирование запросов</summary>
Анализируйте и оптимизируйте запросы, выполняемые внутри транзакций. Используйте профилирование для выявления узких мест и оптимизации запросов для более эффективной работы с базой данных.
</details>

### 30. Какие виды блокировок в SQL знаете

<details>
    <summary>Оптимистическая блокировка</summary>
Оптимистическая блокировка предполагает, что конфликты между транзакциями происходят редко, поэтому каждая транзакция не блокирует доступ к данным для других транзакций.
Вместо этого используются механизмы контроля версий данных, чтобы обнаруживать конфликты и разрешать их. 
Это обычно достигается с помощью использования меток времени или хеш-значений для проверки, были ли данные изменены другими транзакциями после начала текущей транзакции. Если данные были изменены, оптимистическая блокировка может прервать или откатить текущую транзакцию и позволить другой транзакции применить свои изменения.
</details>

<details>
    <summary>Пессимистическая блокировка</summary>
Пессимистическая блокировка используется, когда ожидается возникновение конфликтов между транзакциями.
При пессимистической блокировке транзакция блокирует доступ к данным, чтобы предотвратить изменение или чтение этих данных другими транзакциями.
Это гарантирует, что только одна транзакция имеет доступ к данным в определенное время, но может привести к проблемам с конкурентностью и производительностью, особенно если блокировки длительные или часто возникают.
</details>

### 31. Какими свойствами должна обладать транзакция

<details>
    <summary>Атомарность</summary>
Все команды в транзакции либо полностью выполняются, и соответственно, фиксируются все изменения данных, либо ничего не выполняется и ничего не фиксируется
</details>
<details>
    <summary>Согласованность</summary>
Данные, в случае успешного выполнения транзакции, должны соблюдать все установленные правила в части различных ограничений, первичных и внешних ключей, определенных в базе данных
</details>
<details>
    <summary>Изоляция</summary>
Механизм предоставления доступа к данным. Транзакция изолирует данные, с которыми она работает, для того чтобы другие транзакции получали только согласованные данные;
</details>
<details>
    <summary>Надежность</summary>
Все внесенные изменения фиксируются в журнале транзакций и данные считаются надежными, если транзакция была успешно завершена. В случае сбоя SQL Server сверяет данные, записанные в базе данных, с журналом транзакций, если есть успешно завершенные транзакции, которые не закончили процесс записи всех изменений в базу данных, они будут выполнены повторно. Все действия, выполненные не подтвержденными транзакциями, отменяются.
</details>

### 32. Какие разновидности блокировок вы знаете?

<details>
    <summary>Совмещаемая (Shared) блокировка</summary>

Используются для операций считывания (SELECT) и предотвращают изменение (UPDATE, DELETE) заблокированного ресурса. Как
следует из названия, данная блокировка может быть совмещена с другими блокировками.
В зависимости от уровня изоляции транзакции, блокировка может быть снята, как только данные считаны (Read Committed),
либо же удерживаться до конца транзакции (Repeatable Read и выше).
</details>

<details>
    <summary>Монопольная (Exclusive) блокировка</summary>

Используется для операций изменения данных (UPDATE, DELETE). Данная блокировка не может быть установлена, если
существуют какие-либо другие блокировки на ресурсе, т.е. команда будет ждать снятия всех существующих блокировок.
Будучи успешно установленной, данная блокировка не позволяет установку новых блокировок любых типов, т.е. все запросы,
пытающиеся получить доступ к заблокированному ресурсу, будут ожидать снятия монопольной блокировки.
</details>

<details>
    <summary>Блокировка обновления (Update)</summary>

Он ведёт себя как что-то среднее между совмещаемой (Shared) и монопольной (Exclusive) блокировкой.
«Монопольность» заключается в том, что на ресурсе может быть только одна блокировка обновления, а «совмещаемость» в том, что на этапе
поиска данных блокировка может совмещаться с другими совмещаемыми блокировками.
</details>

### 33. Как можно измененить схемы больших таблиц без простоя?

<details>
    <summary>Online DDL</summary>
Означает изменение схемы таблицы без блокировки доступа к ней. Это достигается путем использования специальных механизмов и алгоритмов, 
которые позволяют выполнять операции изменения схемы параллельно с другими операциями на таблице.
</details>

<details>
    <summary>Репликация</summary>
Изменение на реплике, позволяя основной базе данных продолжать работу.
</details>

<details>
    <summary>Разделение на столбцы</summary>
Разделение изменений на несколько этапов и применение их последовательно к отдельным столбцам или частям таблицы. 
</details>

<details>
    <summary>Оптимизация процесса</summary>
Изучите текущую схему таблицы и процесс обновления, чтобы найти возможности оптимизации. Например, вы можете использовать параллельные
процессы или батчевые операции для ускорения выполнения изменений.
</details>

### 34. Как можно оптимизировать вставку данных в таблицы?

Оптимизировать структуру данных c целью уменьшения размера данных, пакетную вставку, компрессию данных

### 35. Как можно маштабировать данные, и какие виды репликаций бывают?

Масштабировать можно с помощью репликаций. Репликация для чтения - повышает отказаустойчивость.

Виды репликаций: синхронная и асинхоронная (когда запрос от клиента приходит к мастеру, мастер применяет и отвечает клиенту ок и после отправляет в реплику).

Когда работаем с балансом пользователей то нужна синхронная, чтоб данные были консистенты.

Преимущества синхронной downtime нулевой и сразу готовый мастер.

### 36. Алгоритмы выбора лидера в репликации

- Алгоритм забияки

Рассылается всем id, когда один понимает что один узел вышел из строя то рассылается сообщение каждому и тот у которого максимальное число говорит что он мастер

- Запись в БД строчки с expire

Когда перестаёт писать, то другой кто первый запишет строчку тот и мастер

- Определённие консенсуса

На основе голосований о приоритетах и свободных ресурсах выбирается мастер

### 37. В чём преимущества master - master

Можно писать туда и туда.

- Высокая доступность
- Географическая репликация
- Распределенная обработка нагрузки

Недостатки:

- Конфликты идентификаторов
- Нужно синхронизовывать данные

### 38. Какие виды шардирование бывают

- Range base диапазоны
- По полю

### 39. Как работает консистентное хэширование

Представляется круг и зоны в которые попадают ключи, когда ключ попадает в область, мы смотрим какая шарда за этот диапозон отвечает.
Проблема если она будет выходить из строя, то запросы будут идти от другой ноды - каскадный сбой.
Решение использовать виртуальные ноды для каждой физической

### 40. Способы перебалансировки шардов

- Записываем в новый шард, читаем со старого, но запрещаем update и delete
- Добавляем шард, ставим между ними репликацию, ждём когда засинхронизируются потом переводим трафик на новый шард а старый вырубаем

### 41. Что такое партицирование

Отделение используемых записей от старых, по разным таблицам на одном сервере

[Назад](../../README.md)